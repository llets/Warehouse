Index: server/contollers/goodController.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const {Good, Model, Log, Storage, User, Shelf} = require('../models/models')\r\nconst { Op } = require(\"sequelize\");\r\nconst rask = require('../raskroi')\r\nconst ApiError = require('../error/ApiError')\r\nclass GoodController{\r\n    async create(req, res, next){\r\n        try{\r\n            const {userId, string_date_of_arrival, string_models_id, string_goods_amount } = req.body\r\n            let arr_models_id = JSON.parse(string_models_id)\r\n            let arr_goods_amount = JSON.parse(string_goods_amount)\r\n\r\n            arr_goods_amount = arr_goods_amount.map((item) => Number(item))\r\n            arr_models_id = arr_models_id.map((item) => Number(item))\r\n\r\n            // 31-01-2024-23-59\r\n            // 31st of Jan, 2024\r\n            // 23:59\r\n            // or 11:59pm\r\n            let parts = string_date_of_arrival.split('-')\r\n\r\n            // Please pay attention to the month (parts[1]); JavaScript counts months from 0:\r\n            // January - 0, February - 1, etc.\r\n            // creating date: year, month, day, hours, minutes\r\n            let date_of_arrival = new Date(parts[2], parts[1] - 1, parts[0], parts[3], parts[4]);\r\n\r\n            //userId - айди пользователя\r\n            //date_of_arrival - дата прибытия\r\n            //arr_models_id - массив идентификаторов моделей товаров, которые прибыли на склад. Размер n\r\n            //arr_goods_amount - массив количеста товаров для каждой модели соответственно.     Размер n\r\n            // проверка на правильность modelId не нужна, тк выбираем из списка\r\n            if (!userId){\r\n                return next(ApiError.badRequest(\"Отсутствует идентификатор пользователя\"))\r\n            }\r\n            if (!await User.findOne({ where: { id: userId } })){\r\n                return next(ApiError.badRequest(\"Пользователя с заданным идентификатором не существует\"))\r\n            }\r\n            if (!date_of_arrival){\r\n                return next(ApiError.badRequest(\"Не указана дата прибытия товаров\"))\r\n            }\r\n            if (arr_models_id.length !== arr_goods_amount.length){\r\n                return next(ApiError.badRequest(\"Число моделей и количество размеров не совпадает \"))\r\n            }\r\n            if (!arr_models_id){\r\n                return next(ApiError.badRequest(\"Не указана(-ы) модель(-и) товаров\"))\r\n            }\r\n            for (let i = 0; i < arr_models_id.length; i++){\r\n                try {\r\n                    if (!await Model.findOne({where: {id: arr_models_id[i]}})){\r\n                        return next(ApiError.badRequest(`Модели с идентификатором ${arr_models_id[i]} не существует`))\r\n                    }\r\n                }\r\n                catch(e){\r\n                    next(ApiError.badRequest(\"Проверка соответствия идентификаторов пришедших моделей: \" + e.message))\r\n                }\r\n            }\r\n            if (!date_of_arrival){\r\n                return next(ApiError.badRequest(\"Не указано количество товаров соответствующей(-их) модели(-ей)\"))\r\n            }\r\n            // if (!await Model.findOne({ where: { id: modelId } })){\r\n            //     return next(ApiError.badRequest(\"Модели с заданным идентификатором не существует\"))\r\n            // }\r\n\r\n            //Получение данных для упаковки\r\n            //1. Вытаскиваем из бд размеры, которые поступили на склад\r\n            let arr_models_sizes = new Array()\r\n            for (let i = 0; i < arr_models_id.length; i++){\r\n                try{\r\n                    arr_models_sizes.push(await Model.findOne({\r\n                        attributes: ['sizeId'],\r\n                        where: {\r\n                            id: arr_models_id[i]\r\n                        },\r\n                        raw: true   //raw:true нужен для извлечения данных из БД без дополнительных метаданных\r\n                    }))\r\n                }\r\n                catch(e){\r\n                    next(ApiError.badRequest(\"Получение размеров пришедших моделей: \" + e.message))\r\n                }\r\n            }\r\n            \r\n            //2. Вытаскиваем из бд все пустые полки (в порядке возрастания айди) и их количество\r\n            let empty_shelves_count = -1\r\n            let arr_empty_shelves = new Array()\r\n            try{\r\n                arr_empty_shelves = await Shelf.findAll({\r\n                    attributes: ['id'],\r\n                    where:{\r\n                        occupied_size: 0\r\n                    },\r\n                    raw: true,\r\n                    order: [['id', 'ASC']]\r\n                })\r\n                empty_shelves_count = arr_empty_shelves.length \r\n            }\r\n            catch(e){\r\n                next(ApiError.badRequest(\"Получение пустых полок: \" + e.message))\r\n            }\r\n            let arr_empty_shelves_id = new Array()\r\n            for (let i = 0; i < arr_empty_shelves.length; i++){\r\n                arr_empty_shelves_id.push(arr_empty_shelves[i].id)\r\n            }\r\n\r\n            // Нужно найти первую полку из зоны, где ещё нет товаров (самая дальняя пустая полка, при этом полка перед ней не пустая)\r\n            // Если такой нет, то берётся самая последняя полка, которая никогда не должна быть занята.\r\n            let last_empty_shelf_id = '1' \r\n\r\n            //Чтобы найти такую полку мы должны найти последнюю непустую полку.\r\n            //Сначала найдём все полки:\r\n\r\n            let arr_notempty_shelves = new Array()\r\n            try{\r\n                arr_notempty_shelves = await Shelf.findAll({\r\n                    attributes: ['id'],\r\n                    where:{\r\n                        occupied_size:{ [Op.not]: 0 }\r\n                    },\r\n                    raw: true\r\n                })\r\n            }\r\n            catch(e){\r\n                next(ApiError.badRequest(\"Получение непустых полок: \" + e.message))\r\n            }\r\n            let arr_notempty_shelves_id = new Array()\r\n            for (let i = 0; i < arr_notempty_shelves.length; i++){\r\n                arr_notempty_shelves_id.push(arr_notempty_shelves[i].id)\r\n            }\r\n            \r\n            console.log(`arr_empty_shelves_id: ${arr_empty_shelves_id}`)\r\n            //Далее будем с конца проверять, идёт ли после этой непустой полки пустая\r\n            if (arr_notempty_shelves.length == 0)\r\n                last_empty_shelf_id = '1'\r\n            else{\r\n                try{    \r\n                    for(let i = arr_notempty_shelves_id.length - 1; i >= 0; i--){\r\n                        if (arr_empty_shelves_id.includes((parseInt(arr_notempty_shelves_id[i]) + 1).toString())){\r\n                            last_empty_shelf_id = (parseInt(arr_notempty_shelves_id[i]) + 1).toString()\r\n                            break\r\n                        }\r\n                    }\r\n                    // if (last_empty_shelf_id == -1){\r\n                    //     last_empty_shelf_id = 1025\r\n                    // }\r\n                }\r\n                catch(e){\r\n                    next(ApiError.badRequest(\"Проверка, идёт ли после непустой полки пустая: \" + e.message))\r\n                }\r\n            }\r\n            console.log(`last empty shelf id: ${last_empty_shelf_id}`)\r\n\r\n            //3. Вытаскиваем из бд все непустые и не заполненные полки (в порядке возрастания АЙДИ).\r\n            // Это двумерный массив \r\n            let arr_occupied_shelves = new Array()\r\n            let arr_occupied_shelves_id = new Array()\r\n            let arr_occupied_shelves_sizes = new Array()\r\n            try{\r\n                arr_occupied_shelves = await Shelf.findAll({\r\n                    attributes: ['id', 'occupied_size'],\r\n                    where:{\r\n                        occupied_size:{ [Op.between]: [1, 9] }\r\n                    },\r\n                    order:[['id', 'ASC']],\r\n                    raw: true\r\n                })\r\n                console.log(`Колисчество arr_occupied_shelves: ${arr_occupied_shelves.length}`)\r\n                for(let i = 0; i < arr_occupied_shelves.length; i++){\r\n                    arr_occupied_shelves_id.push(arr_occupied_shelves[i].id)\r\n                    arr_occupied_shelves_sizes.push(arr_occupied_shelves[i].occupied_size)\r\n                }\r\n            }\r\n\r\n            catch(e){\r\n                next(ApiError.badRequest(\"Поиск непустых и не заполненных полок: \" + e.message))\r\n            }\r\n\r\n            //4. Вытаскиваем из бд айди последнего товара\r\n            let last_good_id = -1\r\n            try{\r\n                last_good_id = await Good.max('id')\r\n            }\r\n            catch(e){\r\n                next(ApiError.badRequest(e.message))\r\n            }\r\n\r\n            //перевод полученных из бд данных в нормальные массивы, с которыми сможет работать функция Чулпан\r\n            let arr_models_sizes_id = new Array()\r\n            for(let i = 0; i < arr_models_sizes.length; i++){\r\n                arr_models_sizes_id.push(arr_models_sizes[i].sizeId)\r\n            }\r\n            console.log(`sizes: ${(arr_models_sizes_id)}`)\r\n            console.log(`arr_occupied_shelves_id: ${(JSON.stringify(arr_occupied_shelves_id))}`)\r\n            console.log(`arr_occupied_shelves_sizes: ${(JSON.stringify(arr_occupied_shelves_sizes))}`)\r\n            console.log(`arr_empty_shelves_id: ${(JSON.stringify(arr_empty_shelves_id))}`)\r\n\r\n            //получаем айди полок для новых товаров и айди новых товаров из функции Чулпан:\r\n            let add_msg = \"\"\r\n            let arr_shelves_of_new_goods = new Array()\r\n            let arr_id_of_new_goods_of_n_models = new Array()\r\n            const result = rask.add(\r\n                arr_models_id, arr_models_sizes_id, arr_goods_amount, userId,\r\n                empty_shelves_count, arr_occupied_shelves_id, arr_occupied_shelves_sizes,\r\n                arr_empty_shelves_id, last_empty_shelf_id, last_good_id\r\n            )\r\n\r\n            if (result[1] == null || result[2] == null)\r\n            next(ApiError.badRequest(\"Функция раскроя: \" + msg))\r\n\r\n            add_msg = result[0]\r\n            arr_shelves_of_new_goods = result[1]\r\n            arr_id_of_new_goods_of_n_models = result[2]\r\n\r\n            console.log(`Сообщение: ${(add_msg)}`)\r\n            console.log(`Полки: ${(JSON.stringify(arr_shelves_of_new_goods))}`)\r\n            console.log(`Айди товаров: ${(JSON.stringify(arr_id_of_new_goods_of_n_models))}`)\r\n\r\n            //5. Добавляем товары\r\n            let arr_id_new_storages = new Array()\r\n            let arr_id_new_goods = new Array()\r\n            let good_new_id = last_good_id + 1\r\n            try{\r\n                for(let i = 0; i < arr_models_id.length; i++){\r\n                    for (let j = 0; j < arr_goods_amount[i]; j++){\r\n                        \r\n                        //создаём товар\r\n                        \r\n                        try{\r\n                            good_new_id = (await Good.create({\r\n                                    date_of_arrival: date_of_arrival,\r\n                                    modelId: arr_models_id[i]\r\n                                })).id\r\n                        }\r\n                        catch(e){\r\n                            next(ApiError.badRequest(\"Создание товара в бд: \" + e.message))\r\n                        }\r\n\r\n                        //изменяем размер в соответствующей полке\r\n\r\n                        let shelf = new Array()\r\n                        try{\r\n                            shelf.push(await Shelf.findOne({\r\n                                where: {id: arr_shelves_of_new_goods[i][j]\r\n                                },\r\n                                attributes: ['occupied_size']\r\n                            }))\r\n                            console.log(shelf[0].occupied_size)\r\n                        }\r\n                        catch(e){\r\n                            next(ApiError.badRequest(\"Поиск полки в бд: \" + e.message))\r\n                        }\r\n                            let size = parseInt(shelf[0].occupied_size) + parseInt(arr_models_sizes_id[i])\r\n                            console.log(`Размер: ${size}`)\r\n                        try{\r\n                            await Shelf.update({\r\n                                occupied_size: size\r\n                            },\r\n                            {\r\n                                where: {\r\n                                    id: arr_shelves_of_new_goods[i][j]\r\n                                },\r\n                            })\r\n                        }\r\n                        catch(e){\r\n                            next(ApiError.badRequest(\"Сохранение размера полки в бд: \" + e.message))\r\n                        }\r\n\r\n                        //создаём ячейку хранилища\r\n                        \r\n                        try{\r\n                            const storage = await Storage.create({\r\n                                    goodId: good_new_id,\r\n                                    shelfId: arr_shelves_of_new_goods[i][j]\r\n                                })\r\n                                arr_id_new_storages.push(storage.id)\r\n                        }\r\n                        catch(e){\r\n                            next(ApiError.badRequest(\"Создание ячейки хранилища в бд: \" + e.message))\r\n                        }\r\n                        \r\n                        arr_id_new_goods.push(good_new_id)\r\n                        good_new_id += 1\r\n                    }\r\n                }\r\n            }\r\n            catch(e){\r\n                next(ApiError.badRequest(\"Процесс добавления товаров в бд: \" + e.message))\r\n            }\r\n\r\n\r\n            return res.json(`${add_msg} Товары моделей ${arr_models_id} добавлены. Айди новых товаров: ${arr_id_new_goods}. Полки для новых товаров: ${arr_shelves_of_new_goods}. Ячейки для новых товаров: ${arr_id_new_storages}.`)\r\n        }\r\n        catch(e){\r\n            next(ApiError.badRequest(e.message))\r\n        }\r\n    }\r\n    async getAll(req, res){\r\n        const goods = await Good.findAll()\r\n        return res.json(goods)\r\n    }\r\n    async getOne(req, res){\r\n        const {id} = req.params\r\n        const good = await Good.findOne({ where: {id} })\r\n        return res.json(good)\r\n    }\r\n    async deleteOne(req, res, next){\r\n        const {id} = req.params\r\n\r\n        //Из товара вытаскиваем модель, из модели её размер.\r\n        //Из ячейки хранилища вытаскиваем полку, меняем размер полки.\r\n        //Удаляем ячейку хранилища. Удаляем товар.\r\n        //1.1) достаём айди модели\r\n        let model_id\r\n        try{\r\n            model_id = await Good.findOne({\r\n                attributes:['modelId'],\r\n                where:{\r\n                    id: id\r\n                },\r\n                raw: true\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск айди модели удаляемого товара: \" + e.message))\r\n        }\r\n        //1.2) достаём размер из найденной модели\r\n        let size\r\n        try {\r\n            size = await Model.findOne({\r\n                attributes: ['sizeId'],\r\n                where: {\r\n                    id: model_id.modelId\r\n                },\r\n                raw: true\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск размера удаляемого товара: \" + e.message))\r\n        }\r\n        \r\n        //2.1) находим полку, на которой лежит товар\r\n        let shelf_id\r\n        try {\r\n            shelf_id = await Storage.findOne({\r\n                attributes: ['shelfId'],\r\n                where: {\r\n                    goodId: id\r\n                },\r\n                raw: true\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск полки товара: \" + e.message))\r\n        }\r\n        //2.2) достаём размер этой полки\r\n        let curr_shelf_size\r\n        try {\r\n            curr_shelf_size = await Shelf.findOne({\r\n                attributes: ['occupied_size'],\r\n                where: {\r\n                    id: shelf_id.shelfId\r\n                },\r\n                raw: true\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск текущего размера полки: \" + e.message))\r\n        }\r\n\r\n        //2.3) меняем размер этой полки\r\n        const new_size = (curr_shelf_size.occupied_size - size.sizeId).toString()\r\n\r\n        try {\r\n            await Shelf.update({\r\n                occupied_size: new_size\r\n            },\r\n            {\r\n                where: {\r\n                    id: shelf_id.shelfId\r\n                },\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Изменение раземра полки: \" + e.message))\r\n        }\r\n\r\n        //3.1) Удаляем ячейку хранилища\r\n        try{\r\n            await Storage.destroy({\r\n                where: {\r\n                    goodId: id\r\n                }\r\n            });\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Удаление ячейки хранилища: \" + e.message))\r\n        }\r\n        //3.2) Удаляем товар\r\n        try{\r\n            await Good.destroy({\r\n                where: {\r\n                    id: id\r\n                }\r\n            });\r\n            return res.json({message: \"OK\"})\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Удаление товара в БД товаров: \" + e.message))\r\n        }\r\n    }\r\n\r\n    async deleteByModelId(req, res, next){\r\n        // to delete number of goods of the model, we pass this func in a loop\r\n        const {modelId} = req.params\r\n        \r\n        //Находим рандомный товар заданной модели.\r\n        //Из модели вытаскиваем её размер.\r\n        //Из ячейки хранилища вытаскиваем полку, меняем размер полки.\r\n        //Удаляем ячейку хранилища. Удаляем товар.\r\n\r\n        //1. Ищем товар заданной модели\r\n        let id\r\n        try{\r\n            id = await Good.findOne({\r\n                attributes:['id'],\r\n                where:{\r\n                    modelId: modelId\r\n                }\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск товара соответствующей модели для удаления: \" + e.message))\r\n        }\r\n        console.log(id)\r\n        console.log(modelId)\r\n        if (id === undefined || id === null || id < 0){\r\n            return res.json(\"Товаров данной модели на складе нет.\")\r\n        }\r\n\r\n\r\n        //2.1) достаём размер из модели\r\n        let size\r\n        try {\r\n            size = await Model.findOne({\r\n                attributes: ['sizeId'],\r\n                where: {\r\n                    id: modelId\r\n                }\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск размера удаляемого товара: \" + e.message))\r\n        }\r\n        \r\n        //3.1) находим полку, на которой лежит товар\r\n        let shelf_id\r\n        try {\r\n            shelf_id = await Storage.findOne({\r\n                attributes: ['shelfId'],\r\n                where: {\r\n                    goodId: id.id\r\n                }\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск полки товара: \" + e.message))\r\n        }\r\n        //3.2) достаём размер этой полки\r\n        let curr_shelf_size\r\n        try {\r\n            curr_shelf_size = await Shelf.findOne({\r\n                attributes: ['occupied_size'],\r\n                where: {\r\n                    id: shelf_id.shelfId\r\n                }\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Поиск текущего размера полки: \" + e.message))\r\n        }\r\n        //3.3) меняем размер этой полки\r\n        const new_size = (curr_shelf_size.occupied_size - size.sizeId).toString()\r\n\r\n        try {\r\n            await Shelf.update({\r\n                occupied_size: new_size\r\n            },\r\n            {\r\n                where: {\r\n                    id: shelf_id.shelfId\r\n                },\r\n            })\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Изменение раземра полки: \" + e.message))\r\n        }\r\n\r\n        //4.1) Удаляем ячейку хранилища\r\n        try{\r\n            await Storage.destroy({\r\n                where: {\r\n                    goodId: id.id\r\n                }\r\n            });\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Удаление ячейки хранилища: \" + e.message))\r\n        }\r\n        //4.2) Удаляем товар\r\n        try{\r\n            await Good.destroy({\r\n                where: {\r\n                    id: id.id\r\n                }\r\n            });\r\n            return res.json({message: \"OK\"})\r\n        } catch(e){\r\n            next(ApiError.badRequest(\"Удаление товара в БД товаров: \" + e.message))\r\n        }\r\n\r\n    }\r\n}\r\n\r\nmodule.exports = new GoodController()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server/contollers/goodController.js b/server/contollers/goodController.js
--- a/server/contollers/goodController.js	(revision 8c8bf2c68cf2f49201644d88e559dbaf52a5bf9e)
+++ b/server/contollers/goodController.js	(date 1704204017273)
@@ -1,4 +1,4 @@
-const {Good, Model, Log, Storage, User, Shelf} = require('../models/models')
+const {Good, Model, Storage, User, Shelf} = require('../models/models')
 const { Op } = require("sequelize");
 const rask = require('../raskroi')
 const ApiError = require('../error/ApiError')
@@ -63,8 +63,8 @@
             //Получение данных для упаковки
             //1. Вытаскиваем из бд размеры, которые поступили на склад
             let arr_models_sizes = new Array()
-            for (let i = 0; i < arr_models_id.length; i++){
-                try{
+            for (let i = 0; i < arr_models_id.length; i++) {
+                try {
                     arr_models_sizes.push(await Model.findOne({
                         attributes: ['sizeId'],
                         where: {
@@ -72,8 +72,7 @@
                         },
                         raw: true   //raw:true нужен для извлечения данных из БД без дополнительных метаданных
                     }))
-                }
-                catch(e){
+                } catch (e) {
                     next(ApiError.badRequest("Получение размеров пришедших моделей: " + e.message))
                 }
             }
@@ -164,7 +163,8 @@
                 console.log(`Колисчество arr_occupied_shelves: ${arr_occupied_shelves.length}`)
                 for(let i = 0; i < arr_occupied_shelves.length; i++){
                     arr_occupied_shelves_id.push(arr_occupied_shelves[i].id)
-                    arr_occupied_shelves_sizes.push(arr_occupied_shelves[i].occupied_size)
+                    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+                    arr_occupied_shelves_sizes.push(10 - arr_occupied_shelves[i].occupied_size)
                 }
             }
 
@@ -180,12 +180,15 @@
             catch(e){
                 next(ApiError.badRequest(e.message))
             }
-
+            console.log('Last good id = ', last_good_id)
             //перевод полученных из бд данных в нормальные массивы, с которыми сможет работать функция Чулпан
             let arr_models_sizes_id = new Array()
             for(let i = 0; i < arr_models_sizes.length; i++){
                 arr_models_sizes_id.push(arr_models_sizes[i].sizeId)
             }
+
+            arr_models_sizes_id = arr_models_sizes_id.map((item) => Number(item))
+
             console.log(`sizes: ${(arr_models_sizes_id)}`)
             console.log(`arr_occupied_shelves_id: ${(JSON.stringify(arr_occupied_shelves_id))}`)
             console.log(`arr_occupied_shelves_sizes: ${(JSON.stringify(arr_occupied_shelves_sizes))}`)
@@ -201,6 +204,35 @@
                 arr_empty_shelves_id, last_empty_shelf_id, last_good_id
             )
 
+            console.log(arr_models_id)
+            console.log(arr_models_sizes_id)
+            console.log(arr_goods_amount)
+            console.log(userId)
+            console.log(empty_shelves_count)
+            console.log(arr_occupied_shelves_id)
+            console.log(arr_occupied_shelves_sizes)
+            console.log(arr_empty_shelves_id)
+            console.log(last_empty_shelf_id)
+            console.log(last_good_id)
+
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log(result[3])
+            //
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log(result[4])
+            //
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1")
+            // console.log(result[5])
+
             if (result[1] == null || result[2] == null)
             next(ApiError.badRequest("Функция раскроя: " + msg))
 
@@ -426,7 +458,6 @@
             return res.json("Товаров данной модели на складе нет.")
         }
 
-
         //2.1) достаём размер из модели
         let size
         try {
@@ -439,7 +470,7 @@
         } catch(e){
             next(ApiError.badRequest("Поиск размера удаляемого товара: " + e.message))
         }
-        
+        console.log(size)
         //3.1) находим полку, на которой лежит товар
         let shelf_id
         try {
@@ -452,6 +483,7 @@
         } catch(e){
             next(ApiError.badRequest("Поиск полки товара: " + e.message))
         }
+        console.log(shelf_id)
         //3.2) достаём размер этой полки
         let curr_shelf_size
         try {
@@ -464,6 +496,7 @@
         } catch(e){
             next(ApiError.badRequest("Поиск текущего размера полки: " + e.message))
         }
+        console.log(curr_shelf_size)
         //3.3) меняем размер этой полки
         const new_size = (curr_shelf_size.occupied_size - size.sizeId).toString()
 
Index: server/raskroi.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//module.paths.push('/usr/local/lib/node_modules');\r\nconst {lusolve, floor, min, abs, ones, round, multiply, transpose, subtract, sum, det} = require('mathjs')  //npm install mathjs\r\n\r\nconst epsilon=1e-13;\r\n\r\nconst L=10;\r\n\r\n// функция, (иногда) предотвращающая ошибку аппроксимации в js\r\nfunction conversion_num_to_int_if_acceptable(num){\r\n    if (abs(num-round(num)) < epsilon){\r\n        return round(num);\r\n    } else{\r\n        return num;\r\n    }\r\n}\r\n\r\n// часть алгоритма МПУ\r\n// проверка x на оптимальность: если x - оптимальный, то возвращаем его, иначе - возвращаем новые x и alfa\r\nfunction checking_x_for_optimality(alfa,x,n){\r\n\r\n    // Этап 2. Проверить, является ли x оптимальным:\r\n    // Если вектор y - допустимый, то x - оптимальный (по признаку оптимальности).\r\n    // Шаг 1 \r\n    // 1.1\r\n    \r\n    // проверка на лин. зависимость строк матрицы (если строки зависимы, то нельзя найти y)\r\n    if (det(alfa)==0){\r\n        // если матрица оказалась линейной, \r\n        // обнуляем x (тогда b_main[] будет пустым)\r\n        for (let i=0; i<n; i++){\r\n            x[i][0]=0;\r\n        }\r\n        alfa=[];\r\n        return [alfa,x];\r\n    }\r\n    y=lusolve(alfa, ones(n)); // y- двойственный вектор, y[i]−подетальные нормы расхода материала\r\n\r\n    // 1.2. Проверить, является ли y допустимым:\r\n    // Метод ДП для ограниченной задачи о рюкзаке\r\n    // Прямой ход\r\n    f=[];\r\n    i_arr=[];\r\n    for (let i=0; i<L; i++){\r\n        f[i]=0;\r\n        i_arr[i]=0;\r\n    }\r\n\r\n    l0=min(l);\r\n\r\n    for (let j=l0-1; j<L; j++){\r\n        for (let i=0; i<n; i++){\r\n            if (l[i]<=j+1){\r\n                if (f[j]<=(y[i][0]+f[abs(j-l[i])])){\r\n                    f[j]=y[i][0]+f[abs(j-l[i])];\r\n                    i_arr[j]=i+1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Если в результате прямого хода выполнится условие\r\n    if (f[L-1]<=1){\r\n    //     то x - оптимальный вектор\r\n        return [alfa,x];\r\n    }else{\r\n    // иначе, выполняется обратный ход; \r\n    // определяется новый способ раскроя alfa[j0] вместо одного\r\n        alfa_new=[]; // новый способ раскроя \r\n        for (let i=0; i<n; i++){\r\n            alfa_new[i]=0;            \r\n        }\r\n    \r\n        l_tmp=L-1;\r\n        while(l_tmp>=l0-1){\r\n            alfa_new[i_arr[l_tmp]-1] +=1;\r\n            l_tmp -= l[i_arr[l_tmp]-1];\r\n        }\r\n\r\n        // 1.3 Определим, какой из alfa[j] заменим на alfa_new\r\n        // для этого найдем вспомогательный вектор g\r\n        // но сначала проверка матрицы alfa[][] на линейность\r\n        if (det(alfa)==0){\r\n            // если матрица оказалась линейной, \r\n            // обнуляем x (тогда b_main[] будет пустым)\r\n            for (let i=0; i<n; i++){\r\n                x[i][0]=0;\r\n            }\r\n            alfa=[];\r\n            return [alfa,x];\r\n        } else{\r\n            // если матрица нелинейна, все в порядке, действуем дальше по алгоритму\r\n            g=lusolve(alfa, alfa_new);\r\n\r\n            //1.4 \r\n            k_old=0;\r\n            min_e= Number.MAX_SAFE_INTEGER;\r\n            for (let i=0; i<n; i++){\r\n                if (g[i]>0){\r\n                    if (min_e>x[i][0]/g[i][0]){\r\n                        min_e=x[i][0]/g[i][0];\r\n                        min_e=conversion_num_to_int_if_acceptable(min_e);\r\n                        k_old=i; // номер раскроя в alfa, который хотим заменить\r\n                    }\r\n                }\r\n            }\r\n\r\n            // обновляем набор раскроев\r\n            alfa[k_old]=alfa_new;\r\n            // обновляем вектор x - раскройный план\r\n            x_new=new Array(n)\r\n            for (let i=0; i<n; i++){\r\n                x_new[i]=new Array(1)\r\n                x_new[i][0]=0;\r\n            }\r\n\r\n            for (let i=0; i<n; i++){\r\n                if (i==k_old){\r\n                    x_new[i][0]=min_e;\r\n                }\r\n                else if (g[i]>=0){\r\n                    x_new[i][0]=x[i][0]-min_e*g[i][0];\r\n                }else{\r\n                    x_new[i][0]=x[i][0]\r\n                }\r\n            }\r\n            for (let i=0; i<n; i++){\r\n                x[i][0]=x_new[i][0]\r\n            }\r\n        }\r\n        // переходим на этап 2\r\n        return checking_x_for_optimality(alfa,x,n);\r\n        \r\n    }\r\n}\r\n\r\n// алгоритм МПУ\r\nfunction algorithm_mpu(l,b,n){\r\n    // этап 1 Найти исходное допустимое решение – раскрои на заготовки одного вида – однородные раскрои\r\n    // этап 1.1. Найти однородные раскрои\r\n    alfa=new Array(n); // исходные допустимые векторы – однородные раскрои\r\n    for (let i = 0; i < n; i++) {\r\n        alfa[i] = new Array(n);\r\n    }\r\n    for (let i=0; i<n; i++){\r\n        for (let j=0; j<n; j++){\r\n            alfa[i][j]=0;\r\n        }\r\n    }\r\n\r\n    for (let i=0; i<n; i++){\r\n        alfa[i][i]=floor(L/l[i]);\r\n    }\r\n\r\n    // этап 1.2. Найти исходный допустимый раскройный план в расчете на одно изделие:\r\n    x=lusolve(alfa, b); // - раскройный план, количество стержней, которые будут раскраиваться по способу alfa[j]\r\n\r\n    // Этап 2. Проверить, является ли x оптимальным:\r\n    [alfa,x]=checking_x_for_optimality(alfa,x,n);\r\n\r\n    return [alfa,x];\r\n}\r\n\r\n// округляем в нижнюю сторону числа в векторе\r\nfunction round_x_to_bottom(vector,length){\r\n    vector_floor=new Array(length)\r\n    for (let i=0; i<length; i++){\r\n        vector_floor[i]=floor(vector[i])\r\n    }\r\n    return vector_floor;\r\n}\r\n\r\n// начальная обработка входных данных\r\nfunction initial_process_of_input(l,b,n){\r\n    // новые вектора l,b и их длина n, \r\n    // в которых модели с одинаковыми размерами объединены в один элемент векторов(размеры просуммиированы)\r\n    l_new=[];\r\n    b_new=[];\r\n    n_new=0;\r\n    // счетчик кол-ва повторений (необходим для правильного формирования новых векторов)\r\n    count_of_repeats=0; \r\n \r\n    // заполнение новых векторов без повторений в l\r\n    for (let i=0; i<n; ++i){\r\n        l_new.push(l[i]);\r\n        n_new +=1;\r\n        b_new.push(b[i]);\r\n        // проходимся по уже заполненной части вектора l_new \r\n        // и смотрим, нет ли там элемента с таким же значением размера\r\n        for (let j=0; j<i-count_of_repeats; j++){\r\n            if (l[i]==l_new[j]){\r\n                l_new.pop();\r\n                b_new[j] +=b_new.pop();\r\n                n_new -=1;\r\n                count_of_repeats +=1;\r\n            }\r\n        }\r\n    }\r\n \r\n    // т.к., сформировав новые векторы и n, мы потеряли часть информации\r\n    // (об отдельном кол-ве моделей с одинаковыми размерами),\r\n    // необходима возможность ее восстановить - \r\n    // для этого формируем 2мерный массив[n_new][], в котором нулевой элемент в каждой строке - размер из l_new\r\n    // а далее индексы моделей в первоначальных векторах, имеющих этот размер\r\n    arr_of_sizes_place=new Array(n_new);\r\n    for (let i = 0; i < n_new; i++) {\r\n        arr_of_sizes_place[i] = new Array(0);\r\n    }\r\n    for (let i=0; i<n_new; i++){\r\n        arr_of_sizes_place[i].push(l_new[i]);\r\n        for (let j=0; j<n; j++){\r\n            if (arr_of_sizes_place[i][0]==l[j]){\r\n                arr_of_sizes_place[i].push(j);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return [l_new,b_new,n_new, arr_of_sizes_place];\r\n}\r\n\r\n// запуск алгоритма и обработка результата\r\nfunction run_and_preprocess_result_of_algorithm_mpu(l,b,n){\r\n    // запускаем основной алгоритм - алгоритм линейного раскроя\r\n    [alfa,x] = algorithm_mpu(l,b,n);\r\n\r\n    // пост-обработка результата алгоритма\r\n    x_floor =round_x_to_bottom(x,n) // вектор x с округл.-ми в нижн. сторону(т.е. целыми) значениями\r\n\r\n    alfa_T = transpose(alfa) // транспонированная alfa - необходима для дальн. подсчетов\r\n\r\n    b_main=new Array(n); // кол-ва товаров в каждой модели(b) для заполнения полностью пустых полок\r\n    if (alfa.toString()!=([]).toString()){ // если матрица не пуста\r\n        b_main_ = multiply(alfa_T,x_floor);\r\n        for (let i=0; i<n; i++){\r\n            b_main[i]=b_main_[i][0];\r\n        }\r\n    } else{\r\n        for (let i=0; i<n; i++){\r\n            b_main[i]=0;\r\n        }\r\n    }\r\n    b_others = subtract(b,b_main); // кол-ва оставшихся товаров \r\n\r\n    return [alfa,x_floor,b_main, b_others];\r\n}\r\n\r\n// находим кол-во целых полок, необходимых для размещения части(меньшей, в большинстве случаев) товаров\r\n// также (раз уж запустили эту функцию) находим размещения товаров в этих полках\r\nfunction count_shelves_for_b_others_items_fun(l, b_others, n){\r\n    count_of_shelves=0; // кол-во необходимых полок \r\n    arr_x_alfa=[]; // 2-мерный массив, в котором каждая строка - размеры товаров, которые должны быть размещены в одной полке\r\n\r\n    // если изначально b_others[] пуст, т.е. алгоритм МПУ дал целочисленный вектор x[], то выходим из функции\r\n    if (sum(b_others)==0){\r\n        return [count_of_shelves, arr_x_alfa];\r\n    }\r\n    // удаляем пустые элементы b_others[] и соответственные эл-ты l[]\r\n    b__=[];\r\n    l__=[];\r\n    n__=[];\r\n    for (let i=0; i<n; i++){\r\n        if (b_others[i]>0){\r\n            b__.push(b_others[i]);\r\n            l__.push(l[i]);\r\n            n__++;\r\n        }\r\n    }\r\n    b_others=b__;\r\n    l=l__;\r\n    n=n__;\r\n\r\n    // сортируем массив l[] по убыванию, и вместе с ним эл-ты b_others[] также соответственно меняют места,\r\n    // это нужно для наиболее эффективного заполнения полок (сначала пытаемся разместить самые большие товары, далее - что еще влезет в эту полку)\r\n    for (let i=0; i<n; i++){\r\n        for (let j=i+1; j<n; j++){\r\n            if (l[i]<l[j]){\r\n                l_tmp=l[i];\r\n                l[i]=l[j];\r\n                l[j]=l_tmp;\r\n                b_tmp=b_others[i];\r\n                b_others[i]=b_others[j];\r\n                b_others[j]=b_tmp;\r\n            }\r\n        }\r\n    }\r\n\r\n    // заполняем полки и \"запоминаем\" их заполнения в arr_x_alfa[][]\r\n    while (sum(b_others)>0){\r\n        x_alfa=[] // посл-ть размеров товаров, которые должны быть размещены в одной полке\r\n        empty_space_in_shelf=L;\r\n        for (let i=0; i<n; i++){\r\n            if (b_others[i]>0 && l[i]<=empty_space_in_shelf){\r\n                x_alfa.push(l[i]);\r\n                b_others[i]--;\r\n                empty_space_in_shelf -= l[i];\r\n                i--;\r\n            }\r\n        }\r\n        arr_x_alfa.push(x_alfa);\r\n        count_of_shelves +=1;\r\n    }\r\n\r\n    return [count_of_shelves, arr_x_alfa];\r\n}\r\n\r\n// пытаемся заполнить частично пустые полки новыми товарами\r\nfunction fill_partially_empty_shelves(arr_shelvesId, arr_shelvesSizes, l,b,n, arr_id_of_shelves_of_new_goods){\r\n    // копируем массивы l[] и b[] перед сортировкой\r\n    l_old=new Array(n);\r\n    b_old=new Array(n);\r\n    for (let i=0; i<n; i++){\r\n        l_old[i]=l[i];\r\n        b_old[i]=b[i];\r\n    }\r\n    // сортируем массив l[] по убыванию, и вместе с ним эл-ты b[] также соответственно меняют места,\r\n    // это нужно для наиболее эффективного заполнения полок (сначала пытаемся разместить самые большие товары, далее - что еще влезет в эту полку)\r\n    for (let i=0; i<n; i++){\r\n        for (let j=i+1; j<n; j++){\r\n            if (l[i]<l[j]){\r\n                l_tmp=l[i];\r\n                l[i]=l[j];\r\n                l[j]=l_tmp;\r\n                b_tmp=b[i];\r\n                b[i]=b[j];\r\n                b[j]=b_tmp;\r\n            }\r\n        }\r\n    }\r\n\r\n    // сортируем массив arr_shelvesSizes[] по убыванию, и вместе с ним эл-ты arr_shelvesId[] также соответственно меняют места\r\n    // это нужно для более быстрого размещения товаров в случае, если они полностью поместятся в частично свободных\r\n    // length=arr_shelvesSizes.length;\r\n    // for (let i=0; i<length; i++){\r\n    //     for (let j=i+1; j<length; j++){\r\n    //         if (arr_shelvesSizes[i]<arr_shelvesSizes[j]){\r\n    //             arr_shelvesSizes_tmp=arr_shelvesSizes[i];\r\n    //             arr_shelvesSizes[i]=arr_shelvesSizes[j];\r\n    //             arr_shelvesSizes[j]=arr_shelvesSizes_tmp;\r\n    //             arr_shelvesId_tmp=arr_shelvesId[i];\r\n    //             arr_shelvesId[i]=arr_shelvesId[j];\r\n    //             arr_shelvesId[j]=arr_shelvesId_tmp;\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    flag=0;\r\n    // пытаемся максимально заполнить полки и \"запоминаем\" их заполнения сразу в arr_id_of_shelves_of_new_goods[n][]\r\n    while (sum(b)>0 && arr_shelvesId.length>0){ // условием выхода из цикла может быть 2 ситуации: кончились товары для размещения; кончились полки\r\n        empty_space_in_shelf=arr_shelvesSizes.shift(); // незанятое пространство полки\r\n        tmp_shelf_id=arr_shelvesId.shift(); // id частично занятой полки\r\n        if (l[n-1]<=empty_space_in_shelf){ // если свободного места на полке меньше, чем размер самого маленького товара, то нет смысла разместить что-то\r\n            flag=1; // если хотя бы один товар помещается в частично свободные полки, то возвращаемый b будет отличаться\r\n            for (let i=0; i<n; i++){\r\n                if (b[i]>0 && l[i]<=empty_space_in_shelf){ // если товар помещается в полку\r\n                    index_in_l_old=l_old.indexOf(l[i]); // определяем его индекс в первоначальном массиве l[]\r\n                    arr_id_of_shelves_of_new_goods[index_in_l_old].push(tmp_shelf_id); // сохраняем инф. о расположении товара\r\n                    b[i]--; // \"удаляем\" размещенный товар\r\n                    empty_space_in_shelf -= l[i]; // учитываем, что теперь в полке также находится \r\n                    i--; // возможно, товары такого же размера еще могут поместиться на полке, поэтому проверяем этот размер еще раз\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (flag!=0){ // хотя бы один товар был размещен, возвращаем обновленный b\r\n         // переставляем элементы b[] так, чтобы они соответствовали l_old[] \r\n        for (let i=0; i<n; i++){\r\n            index_in_old_version=l_old.indexOf(l[i]);\r\n            b_old[index_in_old_version]=b[i];\r\n        }\r\n    }\r\n\r\n    return [b_old, l_old]; // т.к. мы изменяли элементы в коде функции l[] и b[], то будем возвращать нужные нам l[] и b[]\r\n}\r\n\r\nfunction add(arr_modelsId,l,b, userId, count_of_empty_shelves, arr_shelvesId, arr_shelvesSizes, arr_empty_shelvesId,\r\n    first_empty_shelf_Id, last_id_of_goods){\r\n    //first_empty_shelf_Id = \"1\"\r\n    // 1) Проверяем, что нам хватит места на складе для новых товаров (но, \r\n    //    возможно, товары не удастся разместить, даже если эта проверка прошла)\r\n\r\n    // проверяем входные данные на корректность\r\n    if (arr_modelsId.length!=b.length || b.length!=l.length){\r\n        return [\"Получены некорректные данные!\", null, null];\r\n    }\r\n    n=l.length;\r\n\r\n\r\n    // еще одна прорверка на то, что размер моделей <L\r\n    for (let i=0; i<n; i++){\r\n        if (l[i]>=L){\r\n            return [\"Размер моделей некорректен!\", null, null];\r\n        }\r\n    }\r\n\r\n    // считаем общий размер новых товаров\r\n    new_goods_size=0;\r\n    for (let i=0; i<n; i++){\r\n        new_goods_size += l[i]*b[i];\r\n    }\r\n\r\n    // считаем размер оставшегося места на складе - запросы в бд и сложение\r\n    empty_space_in_warehouse=0;\r\n\r\n    /////////////////////////////////////////////////////////////////////////////////////\r\n    // найти count_of_empty_shelves кол-во полностью свободных полок(у которых occup_size == 0) \r\n    /////////////////////////////////////////////////////////////////////////////////////\r\n    //count_of_empty_shelves=16; // заменить\r\n\r\n    empty_space_in_warehouse +=count_of_empty_shelves*L;\r\n\r\n    /////////////////////////////////////////////////////////////////////////////////////\r\n    // найти и поместить в два одномерных массива или в прямоугольный двумерный массив 2*X \r\n    // все id_полок, которые частично свободны(у которых occup_size != 0) (в первой строке)\r\n    // и соответственно их свободные простр-ва (max_size - occup_size) (во второй строке)\r\n    /////////////////////////////////////////////////////////////////////////////////////\r\n    //arr_shelvesId=[34,56,78,79,83,90,91,92,93,100]; // заменить\r\n    //arr_shelvesSizes=[1,1,3,6,8,2,9,7,8,9]; // заменить\r\n\r\n    len1 = arr_shelvesId.length;\r\n    // проверка на отс. ошибок\r\n    if (arr_shelvesSizes.length != len1){\r\n        return [\"Некорректный запрос к БД 1!\", null, null];\r\n    }\r\n    // если все ок, добавляем размер полупустых полок\r\n    for (let i=0; i<len1; i++){\r\n        empty_space_in_warehouse +=arr_shelvesSizes[i];\r\n    }\r\n\r\n    // если размер всех товаров больше, чем свободное пространство склада, выводим сообщение пользователю об этом\r\n    if (empty_space_in_warehouse<new_goods_size){\r\n        msg=\"Недостаточно места на складе!\";\r\n    }\r\n    else{\r\n        // 2) Предобрабатываем входные данные \r\n\r\n        // делаем копию b, т.к. в ходе работы программы он может изменяться\r\n        b_copy=new Array(n);\r\n        for (let i=0; i<n; i++){\r\n            b_copy[i]=b[i];\r\n        }\r\n\r\n        // создаем непрямоугольный двумерный массив arr_id_of_shelves_of_new_goods[n][] (c кол-вом строк = n),\r\n        // в котором i-я строка - массив размера b[i],\r\n        // заполненный id_полок, в которые будут размещены все новые товары\r\n        arr_id_of_shelves_of_new_goods=new Array(n);\r\n        for(let i=0; i<n; i++){\r\n            arr_id_of_shelves_of_new_goods[i]=new Array(0);\r\n        }\r\n\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        // найти и поместить в массив все id_полок, которые полностью свободны(у которых occup_size == 0)\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        //arr_empty_shelvesId=[1,4,5,8,10,11,12,13,14,15,16,17,18,19,20,21]; // заменить\r\n\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        // найти с конца first_empty_shelf_Id самый маленький id_полки, у которой occup_size ==0, т.е. id_полки такой, \r\n        // что у следующий id_полки-1 occup_size != 0\r\n        // если таких полок нет, т.е. если 1024я полка занята, то пусть id этой полки будет = 1025\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        //first_empty_shelf_Id=10; // заменить \r\n        if (arr_empty_shelvesId.length!=0){\r\n            if (first_empty_shelf_Id==1025){\r\n                // меняем несуществующий id=1025 на последний из существующих id_свободных_полок\r\n                first_empty_shelf_Id=arr_empty_shelvesId[arr_empty_shelvesId.length-1];\r\n            } \r\n        }else{ // 3.0) случай, когда у нас вообще нет свободных полок \r\n            // запускаем функцию размещения в частично свободные полки\r\n\r\n            sum_b_elements=sum(b); // сумма всех эл-в b , нужна будет для проверки, что мы поместили в частично свободные полки хотя бы 1 товар\r\n\r\n            [b,l]=fill_partially_empty_shelves(arr_shelvesId, arr_shelvesSizes, l,b,n, arr_id_of_shelves_of_new_goods);\r\n\r\n            if (sum(b)==0){ // 3.0.1) удалось полностью разместить новые товары в полках, дополнительно никаких размещений не требуется\r\n\r\n                // создаем новые товары, обновляем БД\r\n                for (let i=0; i<arr_id_of_shelves_of_new_goods.length; i++){\r\n                    console.log(arr_id_of_shelves_of_new_goods[i]);\r\n                }\r\n        \r\n                /////////////////////////////////////////////////////////////////////////////////////\r\n                // в переменную last_id_of_goods внести последнюю id_товаров (если нет товаров, то 0)\r\n                /////////////////////////////////////////////////////////////////////////////////////\r\n                //last_id_of_goods=0; // заменить\r\n                tmp_id_of_good=last_id_of_goods+1;\r\n        \r\n                /////////////////////////////////////////////////////////////////////////////////////\r\n                // создаем непрямоугольный двумерный массив arr_id_of_new_goods_of_n_models[n][] (c кол-вом строк = n),\r\n                // в котором i-я строка - массив размера b_copy[i],\r\n                // заполненный id_новых_товаров, их мы генерируем, опираясь на данные last_id_of_goods\r\n                // (значения idшек для 0-й модели: от last_id_of_goods+1 до last_id_of_goods+b_copy[0])\r\n                // и, проходясь циклом по каждому массиву(цикл в цикле), \r\n                // добавляем в таблицу Товаров новые товары i-й модели, беря modelId = arr_modelsId[i] и id_товаров из i-го сгенерированного массива\r\n                // попутно можем обновлять таблицу Лога_действий(если можем)\r\n                /////////////////////////////////////////////////////////////////////////////////////\r\n                // обновляем таблицу Полок, увеличивая occup_size на l[i], если id_полки есть в строке i в arr_id_of_new_goods_of_n_models[][]\r\n                /////////////////////////////////////////////////////////////////////////////////////\r\n                arr_id_of_new_goods_of_n_models= new Array(n);\r\n                for (let i=0; i<n; i++){\r\n                    arr_id_of_new_goods_of_n_models[i]=new Array(b_copy[i]);\r\n                    for (let j=0; j<b_copy[i]; j++){\r\n                        arr_id_of_new_goods_of_n_models[i][j]=tmp_id_of_good;\r\n                        tmp_id_of_good++;\r\n                    }\r\n                }\r\n        \r\n                console.log(\"\\n\");\r\n                for (let i=0; i<arr_id_of_new_goods_of_n_models.length; i++){\r\n                    console.log(arr_id_of_new_goods_of_n_models[i]);\r\n                }\r\n        \r\n                /////////////////////////////////////////////////////////////////////////////////////\r\n                // имея на этом этапе непрямоугольный двумерный массив arr_id_of_shelves_of_new_goods[n][],\r\n                // с помощью цикла в цикле заполняем таблицу Хранилища,\r\n                // беря shelfId = arr_id_of_shelves_of_new_goods[i][j]\r\n                // и goodId = arr_id_of_new_goods_of_n_models[i][j]\r\n                /////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                //console.log(`Иды полок новых товаров: ${arr_id_of_shelves_of_new_goods}`)\r\n                return [\"Все товары успешно размещены на складе!!\", arr_id_of_shelves_of_new_goods, arr_id_of_new_goods_of_n_models];\r\n\r\n            } else{// 3.0.2) не удалось полностью разместить новые товары в полках. т.к. у нас полностью свободных полок, то мы никак не сможем разместить новые товары\r\n                return [\"Недостаточно места на складе!!!!\", null, null];\r\n            }\r\n        }\r\n\r\n        // находим индекс \"начала\" незанятой части склада\r\n        index_of__first_empty_shelf_Id=arr_empty_shelvesId.indexOf(first_empty_shelf_Id);\r\n\r\n        //    если есть товары с одинаковыми размерами, то складываем их кол-ва\r\n        //    (если этого не сделать, алгоритм будет работать неправильно)\r\n        [l_new,b_new,n_new,arr_of_sizes_place] = initial_process_of_input(l,b,n);\r\n\r\n        // 3) Запускаем алгоритм МПУ и проводим предобработку результата:\r\n        //    делим b на b_main и b_others - соответственно отн-ся к тем товарам, \r\n        //    которые займут опр-ное число полностью пустых полок, и оставшимся товарам\r\n        [alfa,x_floor,b_main, b_others]=run_and_preprocess_result_of_algorithm_mpu(l_new,b_new,n_new);\r\n\r\n        // 3.1) Пытаемся разместить все товары в свободной части склада, в полностью свободных полках\r\n\r\n        // находим кол-во целых полок, необходимых для размещения части(большей, но не всегда) товаров\r\n        count_shelves_for_b_main_items=sum(x_floor);\r\n\r\n        // находим кол-во целых полок, необходимых для размещения части(меньшей, но не всегда) товаров\r\n        [count_shelves_for_b_others_items, arr_x_alfa]=count_shelves_for_b_others_items_fun(l_new,b_others, n_new);\r\n        \r\n        if (count_of_empty_shelves>=count_shelves_for_b_main_items+count_shelves_for_b_others_items){\r\n            // 3.2) Если товары помещаются в полностью свободные полки, то находим размещение товаров в них\r\n            // но, возможно, в том числе будут использоваться те пустые полки, которые находятся в занятой части склада\r\n\r\n            // Независимо от того, хватает места в незанятой части склада или нет, формируем массив arr_empty_shelvesId_ordered,\r\n            // который по сути есть переупорядоченный массив arr_empty_shelvesId\r\n            // сначала копируем id_полок незанятой части, далее - занятой\r\n            arr_empty_shelvesId_ordered=[];\r\n            for (let i=index_of__first_empty_shelf_Id; i<arr_empty_shelvesId.length; i++){\r\n                arr_empty_shelvesId_ordered.push(arr_empty_shelvesId[i]);\r\n            }\r\n            for (let i=0; i<index_of__first_empty_shelf_Id; i++){\r\n                arr_empty_shelvesId_ordered.push(arr_empty_shelvesId[i]);\r\n            }\r\n\r\n            // определяем размещение товаров в полках\r\n            // сначала размещаем товары для b_main[]\r\n            // заполняем arr_id_of_shelves_of_new_goods[][], обрабатывая x_floor[] и каждую строку alfa[i]\r\n            // и заполняя возможно сразу несколько строк arr_id_of_shelves_of_new_goods[][]\r\n            if (alfa.toString()!=([]).toString()){ // если матрица не пуста\r\n                for (let i=0; i<n_new; i++){\r\n                    while (x_floor[i][0]>0){\r\n                        tmp_id_shelf=arr_empty_shelvesId_ordered.shift();\r\n                        for (let j=0; j<n_new; j++){\r\n                                for (let k=0; k<alfa[i][j]; k++){\r\n                                    arr_id_of_shelves_of_new_goods[j].push(tmp_id_shelf);\r\n                                }\r\n                            }\r\n                        x_floor[i][0]--;\r\n                    }\r\n                    \r\n                }\r\n            }\r\n            // теперь размещаем товары для b_others[] \r\n            // а здесь обрабатываем построчно arr_x_alfa[]\r\n            for (let i=0; i<count_shelves_for_b_others_items; i++){\r\n                tmp_id_shelf=arr_empty_shelvesId_ordered.shift();\r\n                while (arr_x_alfa[i].length>0){\r\n                    size_of_good=arr_x_alfa[i].pop();\r\n                    index_of_size_in_l_new=l_new.indexOf(size_of_good);\r\n                    arr_id_of_shelves_of_new_goods[index_of_size_in_l_new].push(tmp_id_shelf);\r\n                }\r\n            }\r\n\r\n            // если first_empty_shelf_Id==1025 может сделать его равным arr_empty_shelvesId[length]\r\n        } else{\r\n            // 3.3) Если товары не помещаются в полностью свободные полки,\r\n            //      запускаем функцию размещения в частично свободные полки\r\n\r\n            sum_b_elements=sum(b_new); // сумма всех эл-в b , нужна будет для проверки, что мы поместили в частично свободные полки хотя бы 1 товар\r\n\r\n            [b_new,l_new]=fill_partially_empty_shelves(arr_shelvesId, arr_shelvesSizes, l_new,b_new,n_new, arr_id_of_shelves_of_new_goods);\r\n\r\n            if (sum(b_new)==0){ // 3.3.1) удалось полностью разместить новые товары в полках, дополнительно никаких размещений не требуется\r\n                msg =\"Все товары успешно размещены на складе!\";\r\n            } else if(sum(b_new)==sum_b_elements){ \r\n                // 3.3.2) ни один товар не поместился ни в одну из полок, значит мы не сможем разместить все новые товары в склад в его текущем состоянии\r\n                // возможно, если перемещать размещеннпые ранее товары, то можно добиться достаточного места для новых товаров.\r\n                // но мы не выполняем алгоритм полного перерасчета из той логики, что перестановки старых товаров ради размещения новых могут быть слишком энергозатратны\r\n                console.log(`l: ${l}, b: ${JSON.stringify(b)}`)\r\n                return [\"Недостаточно места на складе!!\", null, null]\r\n            }\r\n            else { // 3.3.3)хотя бы один товар смог поместиться на частично свободных полках\r\n                // проверяем для нового b[], можно ли теперь разместить оставшиеся новые товары в полностью пустых полках\r\n\r\n                //    Запускаем алгоритм МПУ и проводим предобработку результата:\r\n                //    делим b на b_main и b_others - соответственно отн-ся к тем товарам, \r\n                //    которые займут опр-ное число полностью пустых полок, и оставшимся товарам\r\n                [alfa,x_floor,b_main, b_others]=run_and_preprocess_result_of_algorithm_mpu(l_new,b_new,n_new);\r\n\r\n                //    Пытаемся разместить все товары в свободной части склада, в полностью свободных полках\r\n\r\n                // находим кол-во целых полок, необходимых для размещения части(большей, но не всегда) товаров\r\n                count_shelves_for_b_main_items=sum(x_floor);\r\n\r\n                // находим кол-во целых полок, необходимых для размещения части(меньшей, но не всегда) товаров\r\n                [count_shelves_for_b_others_items, arr_x_alfa]=count_shelves_for_b_others_items_fun(l_new,b_others, n_new);\r\n\r\n                if (count_of_empty_shelves>=count_shelves_for_b_main_items+count_shelves_for_b_others_items){\r\n                    // Если товары помещаются в полностью свободные полки, то находим размещение товаров в них\r\n                    // но, возможно, в том числе будут использоваться те пустые полки, которые находятся в занятой части склада\r\n        \r\n                    // находим индекс \"начала\" незанятой части склада\r\n                    index_of__first_empty_shelf_Id=arr_empty_shelvesId.indexOf(first_empty_shelf_Id);\r\n        \r\n                    // Независимо от того, хватает места в незанятой части склада или нет, формируем массив arr_empty_shelvesId_ordered,\r\n                    // который по сути есть переупорядоченный массив arr_empty_shelvesId\r\n                    // сначала копируем id_полок незанятой части, далее - занятой\r\n                    arr_empty_shelvesId_ordered=[];\r\n                    for (let i=index_of__first_empty_shelf_Id; i<arr_empty_shelvesId.length; i++){\r\n                        arr_empty_shelvesId_ordered.push(arr_empty_shelvesId[i]);\r\n                    }\r\n                    for (let i=0; i<index_of__first_empty_shelf_Id; i++){\r\n                        arr_empty_shelvesId_ordered.push(arr_empty_shelvesId[i]);\r\n                    }\r\n        \r\n                    // определяем размещение товаров в полках\r\n                    // сначала размещаем товары для b_main[]\r\n                    // заполняем arr_id_of_shelves_of_new_goods[][], обрабатывая x_floor[] и каждую строку alfa[i]\r\n                    // и заполняя возможно сразу несколько строк arr_id_of_shelves_of_new_goods[][]\r\n                    if (alfa.toString()!=([]).toString()){ // если матрица не пуста\r\n                        for (let i=0; i<n_new; i++){\r\n                            while (x_floor[i][0]>0){\r\n                                tmp_id_shelf=arr_empty_shelvesId_ordered.shift();\r\n                                for (let j=0; j<n_new; j++){\r\n                                        for (let k=0; k<alfa[i][j]; k++){\r\n                                            arr_id_of_shelves_of_new_goods[j].push(tmp_id_shelf);\r\n                                        }\r\n                                    }\r\n                                x_floor[i][0]--;\r\n                            }\r\n                            \r\n                        }\r\n                    }\r\n                    // теперь размещаем товары для b_others[] \r\n                    // а здесь обрабатываем построчно arr_x_alfa[]\r\n                    for (let i=0; i<count_shelves_for_b_others_items; i++){\r\n                        tmp_id_shelf=arr_empty_shelvesId_ordered.shift();\r\n                        while (arr_x_alfa[i].length>0){\r\n                            size_of_good=arr_x_alfa[i].pop();\r\n                            index_of_size_in_l_new=l_new.indexOf(size_of_good);\r\n                            arr_id_of_shelves_of_new_goods[index_of_size_in_l_new].push(tmp_id_shelf);\r\n                        }\r\n                    }\r\n                } else{ // в пустых полках оставшиеся новые товары все равно не могут быть размещены\r\n                    return [\"Недостаточно места на складе!!!\", null, null];\r\n                }\r\n            }\r\n        }\r\n\r\n        // 4) Если мы еще не вышли из функции, значит, разместить товары можно\r\n        // создаем товары, обновляем БД\r\n\r\n        // если b_copy[]!=b_new[], то разделить какую-то строку/-и arr_id_of_shelves_of_new_goods[][]\r\n        if (b_copy.toString()!=b_new.toString()){\r\n            arr_id_of_shelves_of_new_goods__=new Array(n);\r\n            for (let i=0; i<arr_of_sizes_place.length; i++){\r\n                for (let j=1; j<arr_of_sizes_place[i].length; j++){\r\n                    index_of_string_in_arr=arr_of_sizes_place[i][j];\r\n                    arr_id_of_shelves_of_new_goods__[index_of_string_in_arr]=new Array(0);\r\n                    // копируем из матрицы для l_new[] и b_new[] часть id_полок для опр-й модели в нужную строку\r\n                    for (let k=0; k<b_copy[index_of_string_in_arr]; k++){\r\n                        arr_id_of_shelves_of_new_goods__[index_of_string_in_arr].push(arr_id_of_shelves_of_new_goods[i].shift())\r\n                    }\r\n                }\r\n            }\r\n            arr_id_of_shelves_of_new_goods=arr_id_of_shelves_of_new_goods__;\r\n        }\r\n\r\n        for (let i=0; i<arr_id_of_shelves_of_new_goods.length; i++){\r\n            console.log(arr_id_of_shelves_of_new_goods[i]);\r\n        }\r\n\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        // в переменную last_id_of_goods внести последнюю id_товаров (если нет товаров, то 0)\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        //last_id_of_goods=0; // заменить\r\n        tmp_id_of_good=last_id_of_goods+1;\r\n\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        // создаем непрямоугольный двумерный массив arr_id_of_new_goods_of_n_models[n][] (c кол-вом строк = n),\r\n        // в котором i-я строка - массив размера b_copy[i],\r\n        // заполненный id_новых_товаров, их мы генерируем, опираясь на данные last_id_of_goods\r\n        // (значения idшек для 0-й модели: от last_id_of_goods+1 до last_id_of_goods+b_copy[0])\r\n        // и, проходясь циклом по каждому массиву(цикл в цикле), \r\n        // добавляем в таблицу Товаров новые товары i-й модели, беря modelId = arr_modelsId[i] и id_товаров из i-го сгенерированного массива\r\n        // попутно можем обновлять таблицу Лога_действий(если можем)\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        // обновляем таблицу Полок, увеличивая occup_size на l[i], если id_полки есть в строке i в arr_id_of_new_goods_of_n_models[][]\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        arr_id_of_new_goods_of_n_models= new Array(n);\r\n        for (let i=0; i<n; i++){\r\n            arr_id_of_new_goods_of_n_models[i]=new Array(b_copy[i]);\r\n            for (let j=0; j<b_copy[i]; j++){\r\n                arr_id_of_new_goods_of_n_models[i][j]=tmp_id_of_good;\r\n                tmp_id_of_good++;\r\n            }\r\n        }\r\n\r\n        console.log(\"\\n\");\r\n        for (let i=0; i<arr_id_of_new_goods_of_n_models.length; i++){\r\n            console.log(arr_id_of_new_goods_of_n_models[i]);\r\n        }\r\n\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n        // имея на этом этапе непрямоугольный двумерный массив arr_id_of_shelves_of_new_goods[n][],\r\n        // с помощью цикла в цикле заполняем таблицу Хранилища,\r\n        // беря shelfId = arr_id_of_shelves_of_new_goods[i][j]\r\n        // и goodId = arr_id_of_new_goods_of_n_models[i][j]\r\n        /////////////////////////////////////////////////////////////////////////////////////\r\n\r\n        msg=\"Все товары успешно размещены на складе!\";\r\n    }\r\n    //console.log(`иды полок новых товаров: ${JSON.stringify(arr_id_of_shelves_of_new_goods)}`)\r\n    return [msg, arr_id_of_shelves_of_new_goods, arr_id_of_new_goods_of_n_models]\r\n}\r\n\r\narr_modelsId=[23,45,56,6];\r\nl=[3,4,5,7];\r\nb=[3,5,1,1]; //тест для случая 3.0.1\r\n//b=[3,5,3,4];\r\nuserId=1;\r\n\r\n//console.log(add(arr_modelsId,l,b,userId));\r\n\r\nmodule.exports = {add}\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server/raskroi.js b/server/raskroi.js
--- a/server/raskroi.js	(revision 08ff4f41b84e9e860af70cc9bf97a1a05ed09c64)
+++ b/server/raskroi.js	(date 1703423725436)
@@ -129,7 +129,6 @@
         }
         // переходим на этап 2
         return checking_x_for_optimality(alfa,x,n);
-        
     }
 }
 
@@ -374,6 +373,8 @@
 
 function add(arr_modelsId,l,b, userId, count_of_empty_shelves, arr_shelvesId, arr_shelvesSizes, arr_empty_shelvesId,
     first_empty_shelf_Id, last_id_of_goods){
+    arr_id_of_shelves_of_new_goods_2 = []
+    arr_empty_shelvesId_ordered_2 = []
     //first_empty_shelf_Id = "1"
     // 1) Проверяем, что нам хватит места на складе для новых товаров (но, 
     //    возможно, товары не удастся разместить, даже если эта проверка прошла)
@@ -558,15 +559,21 @@
                 arr_empty_shelvesId_ordered.push(arr_empty_shelvesId[i]);
             }
 
+            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+            arr_empty_shelvesId_ordered_2 = []
+            for (let i=0; i<arr_empty_shelvesId_ordered.length; i++){
+                arr_empty_shelvesId_ordered_2.push(arr_empty_shelvesId_ordered[i]);
+            }
+
             // определяем размещение товаров в полках
             // сначала размещаем товары для b_main[]
             // заполняем arr_id_of_shelves_of_new_goods[][], обрабатывая x_floor[] и каждую строку alfa[i]
             // и заполняя возможно сразу несколько строк arr_id_of_shelves_of_new_goods[][]
             if (alfa.toString()!=([]).toString()){ // если матрица не пуста
-                for (let i=0; i<n_new; i++){
+                for (let i=0; i< n_new; i++){
                     while (x_floor[i][0]>0){
-                        tmp_id_shelf=arr_empty_shelvesId_ordered.shift();
                         for (let j=0; j<n_new; j++){
+                            tmp_id_shelf=arr_empty_shelvesId_ordered.shift();
                                 for (let k=0; k<alfa[i][j]; k++){
                                     arr_id_of_shelves_of_new_goods[j].push(tmp_id_shelf);
                                 }
@@ -576,6 +583,14 @@
                     
                 }
             }
+
+            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
+            arr_id_of_shelves_of_new_goods_2 = []
+            for (let i=0; i<arr_id_of_shelves_of_new_goods.length; i++){
+                arr_id_of_shelves_of_new_goods_2.push(arr_id_of_shelves_of_new_goods[i]);
+            }
+
+
             // теперь размещаем товары для b_others[] 
             // а здесь обрабатываем построчно arr_x_alfa[]
             for (let i=0; i<count_shelves_for_b_others_items; i++){
@@ -657,6 +672,20 @@
                             
                         }
                     }
+                    // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
+                    // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
+                    // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
+                    // console.log(JSON.stringify(arr_empty_shelvesId_ordered))
+                    // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
+                    // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
+                    // console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
+
+                    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+                    // arr_id_of_shelves_of_new_goods_2 = []
+                    // for (let i=0; i<arr_id_of_shelves_of_new_goods.length; i++){
+                    //     arr_id_of_shelves_of_new_goods_2.push(arr_id_of_shelves_of_new_goods[i]);
+                    // }
+
                     // теперь размещаем товары для b_others[] 
                     // а здесь обрабатываем построчно arr_x_alfa[]
                     for (let i=0; i<count_shelves_for_b_others_items; i++){
@@ -737,7 +766,8 @@
         msg="Все товары успешно размещены на складе!";
     }
     //console.log(`иды полок новых товаров: ${JSON.stringify(arr_id_of_shelves_of_new_goods)}`)
-    return [msg, arr_id_of_shelves_of_new_goods, arr_id_of_new_goods_of_n_models]
+    return [msg, arr_id_of_shelves_of_new_goods, arr_id_of_new_goods_of_n_models, arr_id_of_shelves_of_new_goods_2,
+        arr_empty_shelvesId_ordered_2, alfa]
 }
 
 arr_modelsId=[23,45,56,6];
